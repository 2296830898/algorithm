
# 模拟栈与链表

## 单链表
[题目链接](https://www.acwing.com/problem/content/828/)
  
实现一个单链表，链表初始为空，支持三种操作：

1. 向链表头插入一个数；
2. 删除第 k个插入的数后面的数；
3. 在第 k 个插入的数后插入一个数。

现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。

**注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，第 n个插入的数。

#### 输入格式

第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

1. `H x`，表示向链表头插入一个数 x。
2. `D k`，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。
3. `I k x`，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。

#### 输出格式

共一行，将整个链表从头到尾输出。

#### 数据范围

1≤M≤100000
所有操作保证合法。

#### 输入样例：

```
10
H 9
I 1 1
D 1
D 0
H 6
I 3 6
I 4 5
I 4 5
I 3 4
D 6
```

#### 输出样例：

```
6 4 6 5
```

#### 思路
一般用两个数组分别来存储结点的值和指针，此处使用`e[N] `和`ne[N]`，那么0号点假设值是3，那么即`e[0] = 3, ne[0] = 1`。如下图所示。
其中空结点下标用-1表示。具体操作：
1.将链表初始化，让头结点为-1，用一个idx表示空余指针结点，或者说轮到哪个空余指针了。
2.head = 表示头结点指向的第一个结点的地址。
所以在头结点插入即表示为
```java
ne[idx] = head;  // 将头结点指向的指针赋给新的结点
e[idx] = k;      // 赋值
head = idx ++ ;  // 头结点指向该新的结点，idx 指向新的空余结点。
```
![[Pasted image 20221205170909.png]]
3.对于题意来说，k被认为是第几个插入的数，而数组从0开始，因此涉及k的操作指向的数组是k - 1的。
4.因此对于k = 0表示头结点删除也需要特判，即`head = next[head]`

### 代码

#### c++
```c++
#include <iostream>

using namespace std;

const int N = 100010;

//head 表示头结点的下标，e[N]表示结点的值，ne[N]表示结点的next指针是多少
//idx用于存储当前已经用到了哪个地址，相当于一个指针。
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;//-1表示空
    idx = 0; //每个点都可以被分配，所以从0开始
}

//将x插入头结点
void add_to_head(int x)
{
    e[idx] = x; //插值
    ne[idx] = head;//插入的结点的下一个指向head指向的结点
    head = idx ++;//head指向当前插入的结点
    //idx用过了，加加
}

//将x插入到第k个输入的点的后面
void add(int k, int x)
{
    e[idx] = x;//如果idx跟k不太符合怎么办？
    ne[idx] = ne[k];//这个插入是顺序插入，而不是任意插入，k和idx一定符合，并且删除并不会影响，此外哪怕是随意插入idx的顺序增加与k也不会导致冲突
    ne[k] = idx ++;//k和idx的值，所以并不影响。
}

//将下标第k个后的点删掉，因为idx从0开始，所以第k实际指的坐标是k - 1
//那么如果k = 0那么就是删去的头结点。
void remove(int k)
{
    ne[k] = ne[ne[k]];   
}

int main()
{
    int m;
    cin >> m;
    
    init();
    while (m -- )
    {
        int k, x;//x是值，k表示第几个。
        char op; //操作符
        
        cin >> op;
        if (op == 'H')
        {
            cin >> x;
            add_to_head(x);
        }
        else if (op == 'D')
        {
            cin >> k;
            //要判定删的是不是头结点。
            if (!k) head = ne[head];//head变成了它指向的点。
            remove(k - 1);
        }
        else
        {
            cin >> k >> x;
            add(k - 1, x);
        }
    }
    //i如果指向的head不是空，那么就输出链表。
    //i = head 表示i变成head指向的点，即头结点的下一个点，此时输出e[i]，
    //然后再让i指向ne[i]即指向下一个点
    for (int i = head; i != -1; i = ne[i]) cout << e[i] << ' ';
    cout << endl;
    
    return 0;
}
```
#### java

```java
import java.util.*;

public class Main {
    static final int N = 100010;
    // idx 表示新的空链表结点，同时也代表第k个插入的数。
    static int n, idx, head;
    static int[] e = new int[N], next = new int[N];

    public static void init() {
        idx = 0;
        head = -1;
    }
    // 在头结点插入一个数，head值表示头结点的地址。
    public static void add_head(int x) {
        e[idx] = x;
        next[idx] = head;
        head = idx ++ ;
    }

    public static void del_node(int k) {
        next[k] = next[next[k]];
    }

    public static void insert_node(int k, int x) {
        next[idx] = next[k];
        e[idx] = x;
        next[k] = idx ++ ;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt();
        init();
        while (n -- > 0) {
            char op = scanner.next().charAt(0);
            //链表头插入
            if (op == 'H') {
                int x = scanner.nextInt();
                add_head(x);
            }
            if (op == 'D') {

                int k = scanner.nextInt();
                if (k == 0) head = next[head];
                else del_node(k - 1);
            }
            if (op == 'I') {
                int k = scanner.nextInt();
                int x = scanner.nextInt();
                insert_node(k - 1, x);
            }
        }
        // 定义一个指针来跑到最后一个地址。
        int res = head;
        while (res != -1) {
            System.out.println(e[res]);
            res = next[res];
        }
    }
}
```

## 双链表
[题目链接](https://www.acwing.com/problem/content/829/)

实现一个双链表，双链表初始为空，支持 5 种操作：

1.  在最左侧插入一个数；
2.  在最右侧插入一个数；
3.  将第 k 个插入的数删除；
4.  在第 k 个插入的数左侧插入一个数；
5.  在第 k 个插入的数右侧插入一个数

现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。

**注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。

#### 输入格式

第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

1.  `L x`，表示在链表的最左端插入数 x。
2.  `R x`，表示在链表的最右端插入数 x。
3.  `D k`，表示将第 k 个插入的数删除。
4.  `IL k x`，表示在第 k 个插入的数左侧插入一个数。
5.  `IR k x`，表示在第 k 个插入的数右侧插入一个数。

#### 输出格式

共一行，将整个链表从左到右输出。

#### 数据范围

1≤M≤100000
所有操作保证合法。

#### 输入样例：

```
10
R 7
D 1
L 3
IL 2 10
D 3
IL 2 7
L 8
R 9
IL 4 7
IR 2 2
```

#### 输出样例：

```
8 7 7 3 2 9
```

#### 思路

双链表相比单链表，需要多一个指向上一结点的数组，但是因为头尾相连，因此不再需要head表示头指针(除非题目特意要求)。
操作原理上与单链表相似
1.idx表示当前空余指针结点
2.`next[]、last[]`表示下一个和上一个，用`next[0]`表示头，`last[1]`表示尾
3.在单链表中，操作 `k - 1` 是因为链表中只存储了当前节点的下一个节点的信息，要找到第 `k` 个位置的节点，需要从头节点开始按序遍历 `k - 1` 次，因为链表中的位置从1开始计数，而链表的索引从0开始。

而在双链表中，idx从2开始，而k是第n个插入的数，k从1开始，因此当第k个数插入时，其对应的地址idx值是k + 1。

，除了存储了当前节点的下一个节点的信息外，还同时存储了当前节点的上一个节点的信息。这种设计使得在双链表中可以更容易地在指定位置进行插入和删除操作，因为通过 `l[]` 和 `r[]` 数组可以直接定位到前后节点。在这个实现中，使用 `l[k + 1]` 或者 `r[k]` 来表示第 `k` 个节点后面的节点。



### 代码

#### java
```java
import java.util.*;  
  
public class Main {  
    static final int N = 100010;  
    // idx 表示新的空链表结点，同时也代表第k个插入的数。  
    static int n, idx;  
    static int[] e = new int[N];  
    static int[] n
    
    ext = new int[N], last = new int[N];  
  
    // 初始化两个头尾结点，这两个结点不存放数据，因此对应的idx为2，即2是新的空闲结点。  
    public static void init() {  
        next[0] = 1;  
        last[1] = 0;  
        idx = 2;  
    }  
    // 画图解决。  
    private static void insert_head(int x) {  
        e[idx] = x;  
        next[idx] = next[0];  
        last[idx] = last[next[0]];  
        last[next[0]] = idx;  
        next[0] = idx ++ ;  
    }  
  
    private static void insert_tail(int x) {  
        e[idx] = x;  
        next[idx] = next[last[1]];  
        last[idx] = last[1];  
        next[last[1]] = idx;  
        last[1] = idx ++ ;  
    }  
  
    private static void insert_right(int k, int x) {  
        e[idx] = x;  
        next[idx] = next[k];  
        last[idx] = last[next[k]];  
        last[next[k]] = idx;  
        next[k] = idx ++ ;  
    }  
  
    private static void insert_left(int k, int x) {  
        e[idx] = x;  
        next[idx] = next[last[k]];  
        last[idx] = last[k];  
        next[last[k]] = idx;  
        last[k] = idx ++ ;  
        System.out.println(idx);  
    }  
  
    private static void del(int k) {  
        last[next[k]] = last[k];  
        next[last[k]] = next[k];  
    }  
  
  
    public static void main(String[] args) {  
        Scanner scanner = new Scanner(System.in);  
        n = scanner.nextInt();  
  
        init();  
        while (n -- > 0) {  
            String str = scanner.next();  
            if ("R".equals(str)) {  
                int x = scanner.nextInt();  
                insert_tail(x);  
            } else if ("L".equals(str)) {  
                int x = scanner.nextInt();  
                insert_head(x);  
            } else if ("D".equals(str)) {  
                int k = scanner.nextInt();  
                // 第n个插入的数，因为idx从2开始，k从1开始，因此其对应的地址的idx值是k + 1  
                del(k + 1);  
            } else if ("IL".equals(str)) {  
                int k = scanner.nextInt();  
                int x = scanner.nextInt();  
                insert_left(k + 1, x);  
            } else if ("IR".equals(str)) {  
                int k = scanner.nextInt();  
                int x = scanner.nextInt();  
                insert_right(k + 1, x);  
            }  
        }  
  
        for (int i = next[0]; i != 1; i = next[i]) {  
            System.out.print(e[i] + " ");  
        }  
    }  
}
```

#### c++

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int m;
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    // 0表示左端点，1表示右端点。
    r[0] = 1;
    l[1] = 0;

    idx = 2;
}
//如果想在k的左边插入一个点，那么直接使用l[k]即k的上一个点的右边即可。
void insert(int k, int x)
{
    //k 和idx存在差值，实际
    //右侧插入
    e[idx] = x;//插值
    r[idx] = r[k];//新结点的右端指向插入结点k指向的右端。
    l[idx] = k;//新结点的左侧指向k。
    l[r[k]] = idx;//下一个点的左端指向新结点。
    r[k] = idx ++ ;//上一个点的右端指向新结点。
}

//删除第k个点。
void remove(int k)
{
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

int main()
{
    init();
    int m;
    cin >> m;
    while (m -- )
    {
        int k, x;
        string op;
        cin >> op;
        if (op == "L")
        {
            //头的右边。
            cin >> x;
            insert(0, x);
        }
        else if (op == "R")
        {
            //尾巴的左边
            cin >> x;
            insert(l[1], x);
        }
        else if (op == "D")
        {
            cin >> k;
            //idx = k + 1;
            //第k个插入的点，它对应的idx下标才是他的实际位置，所以在传输时实际传的是idx。
            remove(k + 1);
        }
        else if (op == "IL")
        {
            cin >> k >> x;
            insert(l[k + 1], x);
        }
        else 
        {
            cin >> k >> x;
            insert(k + 1, x);
        }
    }
    //i从头结点开始，i不是尾结点，i就指向他的右边下一个结点。
    for (int i = r[0]; i != 1; i = r[i]) printf("%d ", e[i]);
    return 0;
}
```


## 模拟栈

实现一个栈，栈初始为空，支持四种操作：

1.  `push x` – 向栈顶插入一个数 x；
2.  `pop` – 从栈顶弹出一个数；
3.  `empty` – 判断栈是否为空；
4.  `query` – 查询栈顶元素。

现在要对栈进行 M 个操作，其中的每个操作 3 和操作4 都要输出相应的结果。

#### 输入格式

第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令为 `push x`，`pop`，`empty`，`query` 中的一种。

#### 输出格式

对于每个 `empty` 和 `query` 操作都要输出一个查询结果，每个结果占一行。

其中，`empty` 操作的查询结果为 `YES` 或 `NO`，`query` 操作的查询结果为一个整数，表示栈顶元素的值。

#### 数据范围

1≤M≤100000
1≤x≤10^9 
所有操作保证合法。

#### 输入样例：

```
10
push 5
query
push 6
pop
query
pop
empty
push 4
query
empty
```

#### 输出样例：

```
5
5
YES
4
NO
```

#### 思路

用一个数组来模拟栈，数组的下标就是栈的对应位置，用一个变量标记当前栈的栈顶，同时也是栈的大小。

### 代码

#### java

```java
import java.util.*;  
  
public class Main {  
    public static int[] stack = new int[100010];  
    public static int top = 0;  
  
    public static void main(String[] args) {  
        Scanner scanner = new Scanner(System.in);  
        int n = scanner.nextInt();  
        while (n -- > 0) {  
            String str = scanner.next();  
            if ("push".equals(str)) {  
                int x = scanner.nextInt();  
                push(x);  
            } else if ("query".equals(str)) {  
                // top表示下一个插入的空地址，栈顶是top - 1
                System.out.println(stack[top - 1]);  
            } else if ("pop".equals(str)) {  
                pop();  
            } else if ("empty".equals(str)) {  
                if (top == 0) System.out.println("YES");  
                else System.out.println("NO");  
            }  
        }  
    }  
  
    private static void pop() {  
        stack[top] = 0;  
        top --;  
    }  
  
    private static void push(int x) {  
        stack[top] = x;  
        top ++ ;  
    }  
}
```

#### c++

```c++
#include <iostream>
#include <string.h>

using namespace std;

const int N = 100010;
//str表示栈名，tt表示栈点的下标。
int str[N], tt;

void push(int x)
{
    tt ++ ;
    str[tt] = x;
}

void pop()
{
    tt --;
}
bool empty()
{
    if (tt > 0) return true;
    else return false;
}

int query()
{
    return str[tt];
}
int main()
{
    int n;
    scanf("%d", &n);

    while (n -- )
    {
        // char op[10];
        // scanf("%s", op);
        bool et = false;
        string op;
        cin >> op;
        //if (!strcmp(op, "push"))
        if (op == "push")
        {
            int x;
            scanf("%d", &x);
            push(x);
        }
        else if (op == "pop") pop();
        else if (op == "empty")
        {
            et = empty();
            if (et) puts("NO");
            else puts("YES");
        }
        else if (op == "query")
        {
            int top = query();
            printf("%d\n", top);
        }
    }

    return 0;
}
```


## 模拟队列

实现一个队列，队列初始为空，支持四种操作：

1.  `push x` – 向队尾插入一个数 x；
2.  `pop` – 从队头弹出一个数；
3.  `empty` – 判断队列是否为空；
4.  `query` – 查询队头元素。

现在要对队列进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。

#### 输入格式

第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令为 `push x`，`pop`，`empty`，`query` 中的一种。

#### 输出格式

对于每个 `empty` 和 `query` 操作都要输出一个查询结果，每个结果占一行。

其中，`empty` 操作的查询结果为 `YES` 或 `NO`，`query` 操作的查询结果为一个整数，表示队头元素的值。

#### 数据范围

1≤M≤100000
1≤x≤10^9
所有操作保证合法。

#### 输入样例：

```
10
push 6
empty
query
pop
empty
push 3
push 4
pop
query
push 6
```

#### 输出样例：

```
NO
6
YES
4
```

#### 思路
用两个结点分别代表头和尾，用一个数组代表队列，新增时尾结点增加，弹出时头结点增加，重复该过程即可。


### 代码
#### java
```java
import java.util.*;

public class Main {
    public static int head = 0;

    public static int tail = 0;

    public static int[] queue = new int[100010];

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();

        while (n -- > 0) {
            String str = scanner.next();
            if ("push".equals(str)) {
                int x = scanner.nextInt();
                push(x);
            } else if ("pop".equals(str)) {
                head ++ ;
            } else if ("empty".equals(str)) {
                if (tail - head == 0) {
                    System.out.println("YES");
                } else System.out.println("NO");
            } else {
                System.out.println(queue[head]);
            }
        }
    }

    private static void push(int x) {
        queue[tail ++ ] = x;
    }
}
```

#### c++
```c++
#include <iostream>

using namespace std;

const int N = 100010;
//队头在0这边，队尾在数组末位。
int q[N], hh, tt = -1;

void insert(int x)
{
    tt ++ ;
    q[tt] = x;
}
void pop()
{
    hh ++ ;
}
bool empty()
{
    // true 代表空,false 代表没空。
    if (tt < hh) return true;
    return false;
}
int query()
{
    return q[hh];
}

int main()
{
    int n;
    scanf("%d", &n);

    while (n -- )
    {
        // char op[10];
        // scanf("%s", op);
        bool et = false;
        string op;
        cin >> op;
        //if (!strcmp(op, "push"))
        if (op == "push")
        {
            int x;
            scanf("%d", &x);
            insert(x);
        }
        else if (op == "pop") pop();
        else if (op == "empty")
        {
            et = empty();
            if (!et) puts("NO");
            else puts("YES");
        }
        else if (op == "query")
        {
            int top = query();
            printf("%d\n", top);
        }
    }

    return 0;
}
```


# 栈与队列的运用

## 单调栈
[原题链接](https://www.acwing.com/problem/content/832/)
给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。

#### 输入格式

第一行包含整数 N，表示数列长度。

第二行包含 N 个整数，表示整数数列。

#### 输出格式

共一行，包含 N 个整数，其中第 i个数表示第i个数的左边第一个比它小的数，如果不存在则输出 −1。

#### 数据范围

1≤N≤10^5
1≤数列中元素≤10^9

#### 输入样例：

```
5
3 4 2 7 5
```

#### 输出样例：

```
-1 3 -1 2 2
```

#### 思路
对于3，4，2，7，5这组数。
栈空，输出-1，3，入栈。
4比3大，输出3，4入栈。
2比4小，4出栈，2比3小，3出栈，，输出-1，2入栈。栈中是2.
7比2大，输出2，7入栈。栈中2，7。
5比7小，7出栈，5比2大，输出2，5入栈，栈中2，5。

总结：栈是单调递增栈，栈顶的元素是新数左边最大的最小值，对于一个新的数，从栈顶开始比较，比该数大的元素全部出栈，直到找到一个数比该数小，将该数输出，然后新数入栈。

用数组stack模拟栈，再用top标识栈顶即可。
### 代码
注：时间复杂度为O(n)

#### java

```java
import java.util.*;

public class Main {
    static int top = -1;
    static int[] stack = new int[100010];

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        while (n -- > 0) {
            int temp = scanner.nextInt();
            // 如果栈空，说明没有数。
            if (top == -1) {
                push(temp);
                System.out.print(-1 + " ");
            } else if (temp > stack[top]) {
                //如果这个数大于栈顶，入栈
                System.out.print(stack[top] + " ");
                push(temp);
            } else if (temp <= stack[top]) {
                //如果数小于等于栈顶，出栈直到栈顶为空或数大于栈顶
                while (top != -1 && temp <= stack[top]) {
                    pop();
                }
                if (top == -1) {
                    System.out.print(-1 + " ");
                    push(temp);
                }
                else {
                    System.out.print(stack[top] + " ");
                    push(temp);
                }
            }
        }
    }

    private static void pop() {
        stack[top] = 0;
        top -- ;
    }

    private static void push(int temp) {
        top ++ ;
        stack[top] = temp;
    }
}
```
#### c++
```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n;
int stk[N], tt;

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ )
    {
         int x;
         scanf("%d", &x);
         //tt不空并且比x大的数全都要出去
         while (tt && stk[tt] >= x) tt -- ;
         //tt还存在说明找到了，否则说明没找到
         if (tt) printf("%d ", stk[tt]);
         else printf("-1 ");
         //最后不管找没找到新的这个数都要入栈，因为没找到栈就空了，找到的话stk[tt] < x也要入栈
         stk[++ tt] = x;
    }
    
    return 0;
}
```

#### 时间复杂度分析
我们可以发现每个元素都只会进栈一次和出栈一次，因此整个算法的时间复杂度是O(n)，因为遇到比栈顶小的数就会删去，n个数你的删除次数不会超过n，比栈顶大的数就会直接入栈，n个数的入栈次数也不会超过n。



## 表达式求值(栈-例题)
[原题链接](https://www.acwing.com/problem/content/3305/)
给定一个表达式，其中运算符仅包含 `+,-,*,/`（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。

**注意：**

-   数据保证给定的表达式合法。
-   题目保证符号 `-` 只作为减号出现，不会作为负号出现，例如，`-1+2`,`(2+2)*(-(1+1)+2)` 之类表达式均不会出现。
-   题目保证表达式中所有数字均为正整数。
-   题目保证表达式在中间计算过程以及结果中，均不超过 2^31−1
-   题目中的整除是指向 0 取整，也就是说对于大于 0 的结果向下取整，例如 5/3=1，对于小于 0 的结果向上取整，例如 5/(1−4)=−1
-   **C++和Java中的整除默认是向零取整**；Python中的整除`//`默认向下取整，因此Python的`eval()`函数中的整除也是向下取整，在本题中不能直接使用。

#### 输入格式

共一行，为给定表达式。

#### 输出格式

共一行，为表达式的结果。

#### 数据范围

表达式的长度不超过 10^5

#### 输入样例：

```
(2+2)*(1+1)
```

#### 输出样例：

```
8
```

#### 思路

1.此题一看就知道需要通过表达式入栈，设定两个栈一个存储数，一个存储操作符进行运算。
难点在于括号的处理或者说表达式优先级处理，需要逐个分析。
对于给定的表达式以及题意`(2 + 2) * (1 + 1)`
主要存在+ - * / ()六个表达式，其中()优先级最高、* / 第二，+-最低。因此有以下几种情况。并存在一个关键点：只有操作运算符出栈时才能相应弹出栈顶的两个操作数
1.栈顶运算符与入栈运算符同级或更高级，此时栈顶运算符出栈，并弹出两个操作数，将操作数计算完毕入栈后，再将新的运算符入栈。
2.栈顶运算符比入栈运算符低级，此时新运算符入栈，栈顶更新即可。
3.遇到左括号，直接入栈，且其优先级是最低。
4.遇到右括号，将栈顶运算符弹出，并弹出两个新的操作数，计算完，新操作数入栈，继续弹出下一个运算符，直到弹出左括号，操作停止。
5.当遍历完整个字符串后，此时操作栈中会残留操作数，需弹出计算。

### 代码
#### java
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String str = scanner.next();

        Stack<Integer> num = new Stack<>();
        Stack<Character> op = new Stack<>();

        Map<Character, Integer> h = new HashMap<>();
            h.put('+', 1);
            h.put('-', 1);
            h.put('*', 2);
            h.put('/', 2);

        for (int i = 0; i < str.length(); i ++ ) {
            if (Character.isDigit(str.charAt(i))) { //isDigit该方法用于判断是否是数字
                int x = 0, j = i;
                //  读取数字
                while (j < str.length() && Character.isDigit(str.charAt(j))) {
                    x = x * 10 + str.charAt(j) - '0';
                    j ++;
                }
                num.push(x);
                i = j - 1;
            } else if (str.charAt(i) == '(') {
                op.push(str.charAt(i));
            } else if (str.charAt(i) == ')') {
                while (!op.isEmpty() && op.peek() != '(') {
                    eval(num, op);
                }
                op.pop();
            } else {
                while (!op.isEmpty() && h.getOrDefault(op.peek(), 0) >= h.get(str.charAt(i))) {
                    eval(num, op);
                }
                op.push(str.charAt(i));
            }
        }

        while (!op.isEmpty()) {
            eval(num, op);
        }

        System.out.println(num.peek());
    }

    private static void eval(Stack<Integer> num, Stack<Character> op) {
        int a = num.pop();
        int b = num.pop();
        char p = op.pop();
        int r = 0;  //记录结果
        if (p == '+') r = b + a;
        if (p == '-') r = b - a;
        if (p == '*') r = b * a;
        if (p == '/') r = b / a;
        
        num.push(r);
    }
}
```

## 单调队列-滑动窗口
[原题链接](https://www.acwing.com/problem/content/submission/156/)
#### 输入格式

输入包含两行。

第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。

第二行有 n 个整数，代表数组的具体数值。

同行数据之间用空格隔开。

#### 输出格式

输出包含两个。

第一行输出，从左至右，每个位置滑动窗口中的最小值。

第二行输出，从左至右，每个位置滑动窗口中的最大值。

#### 输入样例：

```
8 3
1 3 -1 -3 5 3 6 7
```

#### 输出样例：

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7
```

#### 思路分析

暴力做法:
用4个结点，分别记录队头，队尾，队列中的最大值最小值。
先初始化当前窗口k的队列最大最小值。接着开始遍历数组
对于新进来的数，判断其是否大于或小于最大最小值，以最大值为例，若大于最大值，更新最大值并输出到数组中。
若小于最大值，则判断最大值是否在滑动过的窗口区间内，即查找当前最大值的位置i，若在，输出最大值。
若不在数组中，则需要查询当前区间内的最大最小值其所在的位置。
重复上述过程，直到找到最小数组。

上述做法的复杂点在于
1.查找当前最大值是否在区间内。
2.若最大值出队，需要再次查询当前区间内的最大最小值所在。

单调队列法引申：
解决方法：以最大值为例
1.利用坐标进行定位，存储最大值或者说区间内的值对应的定位。如`q[a[i]]`的形式。
经过他人方案考量，其实只要标记这个数再进入窗口时的i值，将这个i值存入即可。
2.在窗口滑动的过程中，如果i代表左侧，j代表右侧，如果j大于i，那么窗口中i就是无意义的，因为只要j在窗口中，最大值一定是j。那么队尾新进来的数j，会与现有队列中的值进行比较，找到其位置。
假如是5，队列是7，3，1。5的下标是j。队列中现有元素的下标是i(因为都在j左侧。)那么5入队后，3和1就失去了意义，重复该过程，队列就一定是单调减队列。而队头元素就是窗口新增元素的最大值。
但是因为窗口还会减去一个head，那么就要判定这个head下标对应的数组值是否就是head，如果是，队头出队，最大值顺延。

上述过程即单调队列的解决方案，并且有效解决了两个问题复杂点，并有效节省了空间开支，不需要再用`q[a[i]]`来做位置标记。
从时间复杂度开支的角度来说，就从暴力法的O(nk)降为了O(n)。

代码思路解析：
求最小值时。
1.当队列非空并且当前数小于队尾值时，队列出栈。当循环结束时，当前数入队。
2.当i移动出了窗口范围`i - k >= 1`并且队头值刚好就是数组窗口头值`a[i - k] == q.peekfirst()`时，队头出队。
3.当i移动到了窗口边界时，开始输出最小值，即输出队头，直到i到达边界，此时窗口同步移动到边界，循环结束。
### 代码

#### c++
```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <deque>
using namespace std;

const int N = 1000010;
int a[N];
int main()
{
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i ++ ) cin >> a[i];//读入数据
    deque<int> q;
    for(int i = 1; i <= n; i++)
    {
        while(q.size() && q.back() > a[i]) //新进入窗口的值小于队尾元素，则队尾出队列
            q.pop_back();
        q.push_back(a[i]);//将新进入的元素入队
        if(i - k >= 1 && q.front() == a[i - k])//若队头是否滑出了窗口，队头出队 
            q.pop_front();
        if(i >= k)//当窗口形成，输出队头对应的值
            cout << q.front() <<" ";
    }
    q.clear();
    cout << endl;

    //最大值亦然
    for(int i = 1; i <= n; i++)
    {
        while(q.size() && q.back() < a[i]) q.pop_back();
        q.push_back(a[i]);
        if(i - k >= 1 && a[i - k] == q.front()) q.pop_front(); 
        if(i >= k) cout << q.front() << " ";

    }
}
```


#### java代码与性能优化过程

初版，跑答案tle
```java
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Scanner;

public class SlidingWindow {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int N = 1000010;
        int[] a = new int[N];

        int n = scanner.nextInt();
        int k = scanner.nextInt();

        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextInt();
        }

        Deque<Integer> q = new ArrayDeque<>();

        // Minimum values
        for (int i = 1; i <= n; i++) {
            while (!q.isEmpty() && q.peekLast() > a[i]) {
                q.pollLast();
            }
            q.offerLast(a[i]);
            if (i - k >= 1 && q.peekFirst() == a[i - k]) {
                q.pollFirst();
            }
            if (i >= k) {
                System.out.print(q.peekFirst() + " ");
            }
        }

        q.clear();
        System.out.println();

        // Maximum values
        for (int i = 1; i <= n; i++) {
            while (!q.isEmpty() && q.peekLast() < a[i]) {
                q.pollLast();
            }
            q.offerLast(a[i]);
            if (i - k >= 1 && a[i - k] == q.peekFirst()) {
                q.pollFirst();
            }
            if (i >= k) {
                System.out.print(q.peekFirst() + " ");
            }
        }

        scanner.close();
    }
}
```

优化输入输出版本
运行时间800ms，可通过
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.StringTokenizer;

public class SlidingWindow {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder result = new StringBuilder();

        int N = 1000010;
        int[] a = new int[N];

        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());
        int n = Integer.parseInt(tokenizer.nextToken());
        int k = Integer.parseInt(tokenizer.nextToken());

        tokenizer = new StringTokenizer(reader.readLine());
        for (int i = 1; i <= n; i++) {
            a[i] = Integer.parseInt(tokenizer.nextToken());
        }

        Deque<Integer> q = new ArrayDeque<>();

        // Minimum values
        for (int i = 1; i <= n; i++) {
            while (!q.isEmpty() && q.peekLast() > a[i]) {
                q.pollLast();
            }
            q.offerLast(a[i]);
            if (i - k >= 1 && q.peekFirst() == a[i - k]) {
                q.pollFirst();
            }
            if (i >= k) {
                result.append(q.peekFirst()).append(" ");
            }
        }

        q.clear();
        result.append("\n");

        // Maximum values
        for (int i = 1; i <= n; i++) {
            while (!q.isEmpty() && q.peekLast() < a[i]) {
                q.pollLast();
            }
            q.offerLast(a[i]);
            if (i - k >= 1 && a[i - k] == q.peekFirst()) {
                q.pollFirst();
            }
            if (i >= k) {
                result.append(q.peekFirst()).append(" ");
            }
        }

        System.out.print(result.toString());

        reader.close();
    }
}
```

优化队列调用改为模拟队列版本
运行时间600ms。
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder result = new StringBuilder();

        int N = 1000010;
        int[] a = new int[N];
        int[] q = new int[N]; // 使用数组模拟队列

        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());
        int n = Integer.parseInt(tokenizer.nextToken());
        int k = Integer.parseInt(tokenizer.nextToken());

        tokenizer = new StringTokenizer(reader.readLine());
        for (int i = 1; i <= n; i++) {
            a[i] = Integer.parseInt(tokenizer.nextToken());
        }

        int frontMin = 1, rearMin = 0;
        int frontMax = 1, rearMax = 0;

        // Minimum values
        for (int i = 1; i <= n; i++) {
            while (rearMin >= frontMin && a[q[rearMin]] > a[i]) {
                rearMin--;
            }
            q[++rearMin] = i;
            if (i - k >= 1 && q[frontMin] == i - k) {
                frontMin++;
            }
            if (i >= k) {
                result.append(a[q[frontMin]]).append(" ");
            }
        }

        result.append("\n");

        // Maximum values
        for (int i = 1; i <= n; i++) {
            while (rearMax >= frontMax && a[q[rearMax]] < a[i]) {
                rearMax--;
            }
            // 队列非空判定。
            q[++rearMax] = i;
            if (i - k >= 1 && q[frontMax] == i - k) {
                frontMax++;
            }
            if (i >= k) {
                result.append(a[q[frontMax]]).append(" ");
            }
        }

        System.out.print(result.toString());

        reader.close();
    }
}
```

# KMP字符串匹配

## 题目

给定一个字符串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模式串 P 在字符串 S中多次作为子串出现。

求出模式串 P 在字符串 S 中所有出现的位置的起始下标。

#### 输入格式

第一行输入整数 N，表示字符串 P 的长度。

第二行输入字符串 P。

第三行输入整数 M，表示字符串 S的长度。

第四行输入字符串 S。

#### 输出格式

共一行，输出所有出现位置的起始下标（下标从 00 开始计数），整数之间用空格隔开。

#### 数据范围

$1≤N≤10^5$
$1≤M≤10^6$

#### 输入样例：

```
3
aba
5
ababa
```

#### 输出样例：

```
0 2
```


### 思路
推荐阅读：[深入浅出 next 数组 ](https://www.acwing.com/solution/content/129372/)
KMP算法的关键在于通过预处理模式串，构建一个辅助数组（部分匹配表），该数组记录了模式串中每个位置的最长相同前缀和后缀的长度。利用这个部分匹配表，算法能够在匹配失败时跳过一定长度，直接移动模式串，而不需要重新比较已经匹配的部分。

核心思想：在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。

相关基本概念：
1、s[ ]是主串，即比较长的字符串。
2、p[ ]是模板串，即比较短的字符串。
3、“部分匹配值”：前缀和后缀的最长共有元素的长度。
4、next[ ]是“部分匹配值表”，即next数组，`next[i]` 存储的就是使子串 `s[0…i]` 有最长相等前后缀的前缀的**最后一位的下标**。是算法的**核心概念**。
如s = “abababc”，`s[0...3]` = abab，k = 1，长度为 k + 1 的前缀与后缀分别是 `s[0…1]` 与 `s[2…3]`。此时`next[i] = 1`。此时存储的就是前缀的最后一位的下标`s[1] = b`。

next数组的求解过程：
1.初始化 next 数组，令 `j = next[0] = -1`。
2、让 i 在 1 ~ len - 1范围内遍历，对每个 i ，执行 3、4，以求解 `next[i]`。
3、直到 j 回退为 -1，或是 `s[i] == s[j + 1]` 成立，否则不断令 `j = next[j]`。
4、如果 `s[i] == s[j + 1]`，则 `next[i] = j + 1`；否则 `next[i] = j`。

不匹配时`j = next[j]`的原因：
因为next[]表示的是当前匹配的前缀最后字符下标，也可以理解为匹配长度，当下一个i字符不匹配时，我们只有缩短匹配串j。对于j的下一个匹配前后缀，在之前计算i时已经计算过了。即上一个存在最大公共j值的位置就是`next[j]`对应的值。也就是新的j缩短后应到的位置。如果一直匹配不到，那么就是j = -1，此时匹配串重新开始。


同理kmp的求解过程：
1、初始化 j = -1，表示 pattern 当前已被匹配的最后位。
2、让 i 遍历文本串 text，对每个 i，执行 3、4来试图匹配 `text[i]` 和`pattern[j + 1]`。
3、直到 j 回退到 -1 或者是 `text[i] == pattern[j + 1]`，否则不断令 `j = next[j]`。
4、如果 `text[i] == pattern[j + 1]`，则令 j ++。如果 j 达到 pattern_len - 1，说明 pattern 是 text 的子串。


结尾输出i - j的原因：
假设在文本串中的位置 `i` 处发生匹配成功，此时 `j` 的值为最长相等前缀的尾部位置。那么 `i - j` 就是文本串中匹配成功的起始位置，因为 `i - j` 表示当前匹配位置减去最长相等前缀的尾部位置，即模式串和文本串匹配的起始位置。


### 代码

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(reader.readLine());
        char[] p = reader.readLine().toCharArray();
        int m = Integer.parseInt(reader.readLine());
        char[] s = reader.readLine().toCharArray();

        int[] ne = new int[n];  //next数组
        ne[0] = -1;
        // 预处理模式串
        for (int i = 1, j = -1; i < n; i ++ ) {
            while (j != -1 && p[i] != p[j + 1]) {
                j = ne[j];
            }
            if (p[i] == p[j + 1]) {
                j ++;
            }
            ne[i] = j;
        }

        StringBuilder result = new StringBuilder();
        // KMP处理
        for (int i = 0, j = -1; i < m; i ++ ) {
            while (j != -1 && s[i] != p[j + 1]) {
                j = ne[j];
            }
            if (s[i] == p[j + 1]) {
                j ++ ;
            }
            if (j == n - 1) {   // j 从-1开始
                result.append(i - j).append(' ');
                j = ne[j];
            }
        }
        System.out.println(result.toString().trim());
    }
}
```