
# 模拟栈与链表

## 单链表
[题目链接](https://www.acwing.com/problem/content/828/)
  
实现一个单链表，链表初始为空，支持三种操作：

1. 向链表头插入一个数；
2. 删除第 k个插入的数后面的数；
3. 在第 k 个插入的数后插入一个数。

现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。

**注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，第 n个插入的数。

#### 输入格式

第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

1. `H x`，表示向链表头插入一个数 x。
2. `D k`，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。
3. `I k x`，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。

#### 输出格式

共一行，将整个链表从头到尾输出。

#### 数据范围

1≤M≤100000
所有操作保证合法。

#### 输入样例：

```
10
H 9
I 1 1
D 1
D 0
H 6
I 3 6
I 4 5
I 4 5
I 3 4
D 6
```

#### 输出样例：

```
6 4 6 5
```

#### 思路
一般用两个数组分别来存储结点的值和指针，此处使用`e[N] `和`ne[N]`，那么0号点假设值是3，那么即`e[0] = 3, ne[0] = 1`。如下图所示。
其中空结点下标用-1表示。具体操作：
1.将链表初始化，让头结点为-1，用一个idx表示空余指针结点，或者说轮到哪个空余指针了。
2.head = 表示头结点指向的第一个结点的地址。
所以在头结点插入即表示为
```java
ne[idx] = head;  // 将头结点指向的指针赋给新的结点
e[idx] = k;      // 赋值
head = idx ++ ;  // 头结点指向该新的结点，idx 指向新的空余结点。
```
![[Pasted image 20221205170909.png]]
3.对于题意来说，k被认为是第几个插入的数，而数组从0开始，因此涉及k的操作指向的数组是k - 1的。
4.因此对于k = 0表示头结点删除也需要特判，即`head = next[head]`

### 代码

#### c++
```c++
#include <iostream>

using namespace std;

const int N = 100010;

//head 表示头结点的下标，e[N]表示结点的值，ne[N]表示结点的next指针是多少
//idx用于存储当前已经用到了哪个地址，相当于一个指针。
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;//-1表示空
    idx = 0; //每个点都可以被分配，所以从0开始
}

//将x插入头结点
void add_to_head(int x)
{
    e[idx] = x; //插值
    ne[idx] = head;//插入的结点的下一个指向head指向的结点
    head = idx ++;//head指向当前插入的结点
    //idx用过了，加加
}

//将x插入到第k个输入的点的后面
void add(int k, int x)
{
    e[idx] = x;//如果idx跟k不太符合怎么办？
    ne[idx] = ne[k];//这个插入是顺序插入，而不是任意插入，k和idx一定符合，并且删除并不会影响，此外哪怕是随意插入idx的顺序增加与k也不会导致冲突
    ne[k] = idx ++;//k和idx的值，所以并不影响。
}

//将下标第k个后的点删掉，因为idx从0开始，所以第k实际指的坐标是k - 1
//那么如果k = 0那么就是删去的头结点。
void remove(int k)
{
    ne[k] = ne[ne[k]];   
}

int main()
{
    int m;
    cin >> m;
    
    init();
    while (m -- )
    {
        int k, x;//x是值，k表示第几个。
        char op; //操作符
        
        cin >> op;
        if (op == 'H')
        {
            cin >> x;
            add_to_head(x);
        }
        else if (op == 'D')
        {
            cin >> k;
            //要判定删的是不是头结点。
            if (!k) head = ne[head];//head变成了它指向的点。
            remove(k - 1);
        }
        else
        {
            cin >> k >> x;
            add(k - 1, x);
        }
    }
    //i如果指向的head不是空，那么就输出链表。
    //i = head 表示i变成head指向的点，即头结点的下一个点，此时输出e[i]，
    //然后再让i指向ne[i]即指向下一个点
    for (int i = head; i != -1; i = ne[i]) cout << e[i] << ' ';
    cout << endl;
    
    return 0;
}
```
#### java

```java
import java.util.*;

public class Main {
    static final int N = 100010;
    // idx 表示新的空链表结点，同时也代表第k个插入的数。
    static int n, idx, head;
    static int[] e = new int[N], next = new int[N];

    public static void init() {
        idx = 0;
        head = -1;
    }
    // 在头结点插入一个数，head值表示头结点的地址。
    public static void add_head(int x) {
        e[idx] = x;
        next[idx] = head;
        head = idx ++ ;
    }

    public static void del_node(int k) {
        next[k] = next[next[k]];
    }

    public static void insert_node(int k, int x) {
        next[idx] = next[k];
        e[idx] = x;
        next[k] = idx ++ ;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt();
        init();
        while (n -- > 0) {
            char op = scanner.next().charAt(0);
            //链表头插入
            if (op == 'H') {
                int x = scanner.nextInt();
                add_head(x);
            }
            if (op == 'D') {

                int k = scanner.nextInt();
                if (k == 0) head = next[head];
                else del_node(k - 1);
            }
            if (op == 'I') {
                int k = scanner.nextInt();
                int x = scanner.nextInt();
                insert_node(k - 1, x);
            }
        }
        // 定义一个指针来跑到最后一个地址。
        int res = head;
        while (res != -1) {
            System.out.println(e[res]);
            res = next[res];
        }
    }
}
```

## 双链表
[题目链接](https://www.acwing.com/problem/content/829/)

实现一个双链表，双链表初始为空，支持 5 种操作：

1.  在最左侧插入一个数；
2.  在最右侧插入一个数；
3.  将第 k 个插入的数删除；
4.  在第 k 个插入的数左侧插入一个数；
5.  在第 k 个插入的数右侧插入一个数

现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。

**注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。

#### 输入格式

第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

1.  `L x`，表示在链表的最左端插入数 x。
2.  `R x`，表示在链表的最右端插入数 x。
3.  `D k`，表示将第 k 个插入的数删除。
4.  `IL k x`，表示在第 k 个插入的数左侧插入一个数。
5.  `IR k x`，表示在第 k 个插入的数右侧插入一个数。

#### 输出格式

共一行，将整个链表从左到右输出。

#### 数据范围

1≤M≤100000
所有操作保证合法。

#### 输入样例：

```
10
R 7
D 1
L 3
IL 2 10
D 3
IL 2 7
L 8
R 9
IL 4 7
IR 2 2
```

#### 输出样例：

```
8 7 7 3 2 9
```

#### 思路

双链表相比单链表，需要多一个指向上一结点的数组，但是因为头尾相连，因此不再需要head表示头指针(除非题目特意要求)。
操作原理上与单链表相似
1.idx表示当前空余指针结点
2.`next[]、last[]`表示下一个和上一个，用`next[0]`表示头，`last[1]`表示尾
3.在单链表中，操作 `k - 1` 是因为链表中只存储了当前节点的下一个节点的信息，要找到第 `k` 个位置的节点，需要从头节点开始按序遍历 `k - 1` 次，因为链表中的位置从1开始计数，而链表的索引从0开始。

而在双链表中，idx从2开始，而k是第n个插入的数，k从1开始，因此当第k个数插入时，其对应的地址idx值是k + 1。

，除了存储了当前节点的下一个节点的信息外，还同时存储了当前节点的上一个节点的信息。这种设计使得在双链表中可以更容易地在指定位置进行插入和删除操作，因为通过 `l[]` 和 `r[]` 数组可以直接定位到前后节点。在这个实现中，使用 `l[k + 1]` 或者 `r[k]` 来表示第 `k` 个节点后面的节点。



### 代码

#### java
```java
import java.util.*;  
  
public class Main {  
    static final int N = 100010;  
    // idx 表示新的空链表结点，同时也代表第k个插入的数。  
    static int n, idx;  
    static int[] e = new int[N];  
    static int[] n
    
    ext = new int[N], last = new int[N];  
  
    // 初始化两个头尾结点，这两个结点不存放数据，因此对应的idx为2，即2是新的空闲结点。  
    public static void init() {  
        next[0] = 1;  
        last[1] = 0;  
        idx = 2;  
    }  
    // 画图解决。  
    private static void insert_head(int x) {  
        e[idx] = x;  
        next[idx] = next[0];  
        last[idx] = last[next[0]];  
        last[next[0]] = idx;  
        next[0] = idx ++ ;  
    }  
  
    private static void insert_tail(int x) {  
        e[idx] = x;  
        next[idx] = next[last[1]];  
        last[idx] = last[1];  
        next[last[1]] = idx;  
        last[1] = idx ++ ;  
    }  
  
    private static void insert_right(int k, int x) {  
        e[idx] = x;  
        next[idx] = next[k];  
        last[idx] = last[next[k]];  
        last[next[k]] = idx;  
        next[k] = idx ++ ;  
    }  
  
    private static void insert_left(int k, int x) {  
        e[idx] = x;  
        next[idx] = next[last[k]];  
        last[idx] = last[k];  
        next[last[k]] = idx;  
        last[k] = idx ++ ;  
        System.out.println(idx);  
    }  
  
    private static void del(int k) {  
        last[next[k]] = last[k];  
        next[last[k]] = next[k];  
    }  
  
  
    public static void main(String[] args) {  
        Scanner scanner = new Scanner(System.in);  
        n = scanner.nextInt();  
  
        init();  
        while (n -- > 0) {  
            String str = scanner.next();  
            if ("R".equals(str)) {  
                int x = scanner.nextInt();  
                insert_tail(x);  
            } else if ("L".equals(str)) {  
                int x = scanner.nextInt();  
                insert_head(x);  
            } else if ("D".equals(str)) {  
                int k = scanner.nextInt();  
                // 第n个插入的数，因为idx从2开始，k从1开始，因此其对应的地址的idx值是k + 1  
                del(k + 1);  
            } else if ("IL".equals(str)) {  
                int k = scanner.nextInt();  
                int x = scanner.nextInt();  
                insert_left(k + 1, x);  
            } else if ("IR".equals(str)) {  
                int k = scanner.nextInt();  
                int x = scanner.nextInt();  
                insert_right(k + 1, x);  
            }  
        }  
  
        for (int i = next[0]; i != 1; i = next[i]) {  
            System.out.print(e[i] + " ");  
        }  
    }  
}
```

#### c++

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int m;
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    // 0表示左端点，1表示右端点。
    r[0] = 1;
    l[1] = 0;

    idx = 2;
}
//如果想在k的左边插入一个点，那么直接使用l[k]即k的上一个点的右边即可。
void insert(int k, int x)
{
    //k 和idx存在差值，实际
    //右侧插入
    e[idx] = x;//插值
    r[idx] = r[k];//新结点的右端指向插入结点k指向的右端。
    l[idx] = k;//新结点的左侧指向k。
    l[r[k]] = idx;//下一个点的左端指向新结点。
    r[k] = idx ++ ;//上一个点的右端指向新结点。
}

//删除第k个点。
void remove(int k)
{
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

int main()
{
    init();
    int m;
    cin >> m;
    while (m -- )
    {
        int k, x;
        string op;
        cin >> op;
        if (op == "L")
        {
            //头的右边。
            cin >> x;
            insert(0, x);
        }
        else if (op == "R")
        {
            //尾巴的左边
            cin >> x;
            insert(l[1], x);
        }
        else if (op == "D")
        {
            cin >> k;
            //idx = k + 1;
            //第k个插入的点，它对应的idx下标才是他的实际位置，所以在传输时实际传的是idx。
            remove(k + 1);
        }
        else if (op == "IL")
        {
            cin >> k >> x;
            insert(l[k + 1], x);
        }
        else 
        {
            cin >> k >> x;
            insert(k + 1, x);
        }
    }
    //i从头结点开始，i不是尾结点，i就指向他的右边下一个结点。
    for (int i = r[0]; i != 1; i = r[i]) printf("%d ", e[i]);
    return 0;
}
```


## 模拟栈

实现一个栈，栈初始为空，支持四种操作：

1.  `push x` – 向栈顶插入一个数 x；
2.  `pop` – 从栈顶弹出一个数；
3.  `empty` – 判断栈是否为空；
4.  `query` – 查询栈顶元素。

现在要对栈进行 M 个操作，其中的每个操作 3 和操作4 都要输出相应的结果。

#### 输入格式

第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令为 `push x`，`pop`，`empty`，`query` 中的一种。

#### 输出格式

对于每个 `empty` 和 `query` 操作都要输出一个查询结果，每个结果占一行。

其中，`empty` 操作的查询结果为 `YES` 或 `NO`，`query` 操作的查询结果为一个整数，表示栈顶元素的值。

#### 数据范围

1≤M≤100000
1≤x≤10^9 
所有操作保证合法。

#### 输入样例：

```
10
push 5
query
push 6
pop
query
pop
empty
push 4
query
empty
```

#### 输出样例：

```
5
5
YES
4
NO
```

#### 思路

用一个数组来模拟栈，数组的下标就是栈的对应位置，用一个变量标记当前栈的栈顶，同时也是栈的大小。

### 代码

#### java

```java
import java.util.*;  
  
public class Main {  
    public static int[] stack = new int[100010];  
    public static int top = 0;  
  
    public static void main(String[] args) {  
        Scanner scanner = new Scanner(System.in);  
        int n = scanner.nextInt();  
        while (n -- > 0) {  
            String str = scanner.next();  
            if ("push".equals(str)) {  
                int x = scanner.nextInt();  
                push(x);  
            } else if ("query".equals(str)) {  
                // top表示下一个插入的空地址，栈顶是top - 1
                System.out.println(stack[top - 1]);  
            } else if ("pop".equals(str)) {  
                pop();  
            } else if ("empty".equals(str)) {  
                if (top == 0) System.out.println("YES");  
                else System.out.println("NO");  
            }  
        }  
    }  
  
    private static void pop() {  
        stack[top] = 0;  
        top --;  
    }  
  
    private static void push(int x) {  
        stack[top] = x;  
        top ++ ;  
    }  
}
```

#### c++

```c++
#include <iostream>
#include <string.h>

using namespace std;

const int N = 100010;
//str表示栈名，tt表示栈点的下标。
int str[N], tt;

void push(int x)
{
    tt ++ ;
    str[tt] = x;
}

void pop()
{
    tt --;
}
bool empty()
{
    if (tt > 0) return true;
    else return false;
}

int query()
{
    return str[tt];
}
int main()
{
    int n;
    scanf("%d", &n);

    while (n -- )
    {
        // char op[10];
        // scanf("%s", op);
        bool et = false;
        string op;
        cin >> op;
        //if (!strcmp(op, "push"))
        if (op == "push")
        {
            int x;
            scanf("%d", &x);
            push(x);
        }
        else if (op == "pop") pop();
        else if (op == "empty")
        {
            et = empty();
            if (et) puts("NO");
            else puts("YES");
        }
        else if (op == "query")
        {
            int top = query();
            printf("%d\n", top);
        }
    }

    return 0;
}
```


## 模拟队列

实现一个队列，队列初始为空，支持四种操作：

1.  `push x` – 向队尾插入一个数 x；
2.  `pop` – 从队头弹出一个数；
3.  `empty` – 判断队列是否为空；
4.  `query` – 查询队头元素。

现在要对队列进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。

#### 输入格式

第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令为 `push x`，`pop`，`empty`，`query` 中的一种。

#### 输出格式

对于每个 `empty` 和 `query` 操作都要输出一个查询结果，每个结果占一行。

其中，`empty` 操作的查询结果为 `YES` 或 `NO`，`query` 操作的查询结果为一个整数，表示队头元素的值。

#### 数据范围

1≤M≤100000
1≤x≤10^9
所有操作保证合法。

#### 输入样例：

```
10
push 6
empty
query
pop
empty
push 3
push 4
pop
query
push 6
```

#### 输出样例：

```
NO
6
YES
4
```

#### 思路
用两个结点分别代表头和尾，用一个数组代表队列，新增时尾结点增加，弹出时头结点增加，重复该过程即可。


### 代码
#### java
```java
import java.util.*;

public class Main {
    public static int head = 0;

    public static int tail = 0;

    public static int[] queue = new int[100010];

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();

        while (n -- > 0) {
            String str = scanner.next();
            if ("push".equals(str)) {
                int x = scanner.nextInt();
                push(x);
            } else if ("pop".equals(str)) {
                head ++ ;
            } else if ("empty".equals(str)) {
                if (tail - head == 0) {
                    System.out.println("YES");
                } else System.out.println("NO");
            } else {
                System.out.println(queue[head]);
            }
        }
    }

    private static void push(int x) {
        queue[tail ++ ] = x;
    }
}
```

#### c++
```c++
#include <iostream>

using namespace std;

const int N = 100010;
//队头在0这边，队尾在数组末位。
int q[N], hh, tt = -1;

void insert(int x)
{
    tt ++ ;
    q[tt] = x;
}
void pop()
{
    hh ++ ;
}
bool empty()
{
    // true 代表空,false 代表没空。
    if (tt < hh) return true;
    return false;
}
int query()
{
    return q[hh];
}

int main()
{
    int n;
    scanf("%d", &n);

    while (n -- )
    {
        // char op[10];
        // scanf("%s", op);
        bool et = false;
        string op;
        cin >> op;
        //if (!strcmp(op, "push"))
        if (op == "push")
        {
            int x;
            scanf("%d", &x);
            insert(x);
        }
        else if (op == "pop") pop();
        else if (op == "empty")
        {
            et = empty();
            if (!et) puts("NO");
            else puts("YES");
        }
        else if (op == "query")
        {
            int top = query();
            printf("%d\n", top);
        }
    }

    return 0;
}
```


# 栈与队列的运用

## 单调栈
[原题链接](https://www.acwing.com/problem/content/832/)
给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。

#### 输入格式

第一行包含整数 N，表示数列长度。

第二行包含 N 个整数，表示整数数列。

#### 输出格式

共一行，包含 N 个整数，其中第 i个数表示第i个数的左边第一个比它小的数，如果不存在则输出 −1。

#### 数据范围

1≤N≤10^5
1≤数列中元素≤10^9

#### 输入样例：

```
5
3 4 2 7 5
```

#### 输出样例：

```
-1 3 -1 2 2
```

#### 思路
对于3，4，2，7，5这组数。
栈空，输出-1，3，入栈。
4比3大，输出3，4入栈。
2比4小，4出栈，2比3小，3出栈，，输出-1，2入栈。栈中是2.
7比2大，输出2，7入栈。栈中2，7。
5比7小，7出栈，5比2大，输出2，5入栈，栈中2，5。

总结：栈是单调递增栈，栈顶的元素是新数左边最大的最小值，对于一个新的数，从栈顶开始比较，比该数大的元素全部出栈，直到找到一个数比该数小，将该数输出，然后新数入栈。

用数组stack模拟栈，再用top标识栈顶即可。
### 代码
注：时间复杂度为O(n)

#### java

```java
import java.util.*;

public class Main {
    static int top = -1;
    static int[] stack = new int[100010];

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        while (n -- > 0) {
            int temp = scanner.nextInt();
            // 如果栈空，说明没有数。
            if (top == -1) {
                push(temp);
                System.out.print(-1 + " ");
            } else if (temp > stack[top]) {
                //如果这个数大于栈顶，入栈
                System.out.print(stack[top] + " ");
                push(temp);
            } else if (temp <= stack[top]) {
                //如果数小于等于栈顶，出栈直到栈顶为空或数大于栈顶
                while (top != -1 && temp <= stack[top]) {
                    pop();
                }
                if (top == -1) {
                    System.out.print(-1 + " ");
                    push(temp);
                }
                else {
                    System.out.print(stack[top] + " ");
                    push(temp);
                }
            }
        }
    }

    private static void pop() {
        stack[top] = 0;
        top -- ;
    }

    private static void push(int temp) {
        top ++ ;
        stack[top] = temp;
    }
}
```
#### c++
```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n;
int stk[N], tt;

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ )
    {
         int x;
         scanf("%d", &x);
         //tt不空并且比x大的数全都要出去
         while (tt && stk[tt] >= x) tt -- ;
         //tt还存在说明找到了，否则说明没找到
         if (tt) printf("%d ", stk[tt]);
         else printf("-1 ");
         //最后不管找没找到新的这个数都要入栈，因为没找到栈就空了，找到的话stk[tt] < x也要入栈
         stk[++ tt] = x;
    }
    
    return 0;
}
```

#### 时间复杂度分析
我们可以发现每个元素都只会进栈一次和出栈一次，因此整个算法的时间复杂度是O(n)，因为遇到比栈顶小的数就会删去，n个数你的删除次数不会超过n，比栈顶大的数就会直接入栈，n个数的入栈次数也不会超过n。



## 表达式求值(栈-例题)
[原题链接](https://www.acwing.com/problem/content/3305/)
给定一个表达式，其中运算符仅包含 `+,-,*,/`（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。

**注意：**

-   数据保证给定的表达式合法。
-   题目保证符号 `-` 只作为减号出现，不会作为负号出现，例如，`-1+2`,`(2+2)*(-(1+1)+2)` 之类表达式均不会出现。
-   题目保证表达式中所有数字均为正整数。
-   题目保证表达式在中间计算过程以及结果中，均不超过 2^31−1
-   题目中的整除是指向 0 取整，也就是说对于大于 0 的结果向下取整，例如 5/3=1，对于小于 0 的结果向上取整，例如 5/(1−4)=−1
-   **C++和Java中的整除默认是向零取整**；Python中的整除`//`默认向下取整，因此Python的`eval()`函数中的整除也是向下取整，在本题中不能直接使用。

#### 输入格式

共一行，为给定表达式。

#### 输出格式

共一行，为表达式的结果。

#### 数据范围

表达式的长度不超过 10^5

#### 输入样例：

```
(2+2)*(1+1)
```

#### 输出样例：

```
8
```

#### 思路

1.此题一看就知道需要通过表达式入栈，设定两个栈一个存储数，一个存储操作符进行运算。
难点在于括号的处理或者说表达式优先级处理，需要逐个分析。
对于给定的表达式以及题意`(2 + 2) * (1 + 1)`
主要存在+ - * / ()六个表达式，其中()优先级最高、* / 第二，+-最低。因此有以下几种情况。并存在一个关键点：只有操作运算符出栈时才能相应弹出栈顶的两个操作数
1.栈顶运算符与入栈运算符同级或更高级，此时栈顶运算符出栈，并弹出两个操作数，将操作数计算完毕入栈后，再将新的运算符入栈。
2.栈顶运算符比入栈运算符低级，此时新运算符入栈，栈顶更新即可。
3.遇到左括号，直接入栈，且其优先级是最低。
4.遇到右括号，将栈顶运算符弹出，并弹出两个新的操作数，计算完，新操作数入栈，继续弹出下一个运算符，直到弹出左括号，操作停止。
5.当遍历完整个字符串后，此时操作栈中会残留操作数，需弹出计算。

### 代码
#### java
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String str = scanner.next();

        Stack<Integer> num = new Stack<>();
        Stack<Character> op = new Stack<>();

        Map<Character, Integer> h = new HashMap<>();
            h.put('+', 1);
            h.put('-', 1);
            h.put('*', 2);
            h.put('/', 2);

        for (int i = 0; i < str.length(); i ++ ) {
            if (Character.isDigit(str.charAt(i))) { //isDigit该方法用于判断是否是数字
                int x = 0, j = i;
                //  读取数字
                while (j < str.length() && Character.isDigit(str.charAt(j))) {
                    x = x * 10 + str.charAt(j) - '0';
                    j ++;
                }
                num.push(x);
                i = j - 1;
            } else if (str.charAt(i) == '(') {
                op.push(str.charAt(i));
            } else if (str.charAt(i) == ')') {
                while (!op.isEmpty() && op.peek() != '(') {
                    eval(num, op);
                }
                op.pop();
            } else {
                while (!op.isEmpty() && h.getOrDefault(op.peek(), 0) >= h.get(str.charAt(i))) {
                    eval(num, op);
                }
                op.push(str.charAt(i));
            }
        }

        while (!op.isEmpty()) {
            eval(num, op);
        }

        System.out.println(num.peek());
    }

    private static void eval(Stack<Integer> num, Stack<Character> op) {
        int a = num.pop();
        int b = num.pop();
        char p = op.pop();
        int r = 0;  //记录结果
        if (p == '+') r = b + a;
        if (p == '-') r = b - a;
        if (p == '*') r = b * a;
        if (p == '/') r = b / a;
        
        num.push(r);
    }
}
```

## 单调队列-滑动窗口
[原题链接](https://www.acwing.com/problem/content/submission/156/)
#### 输入格式

输入包含两行。

第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。

第二行有 n 个整数，代表数组的具体数值。

同行数据之间用空格隔开。

#### 输出格式

输出包含两个。

第一行输出，从左至右，每个位置滑动窗口中的最小值。

第二行输出，从左至右，每个位置滑动窗口中的最大值。

#### 输入样例：

```
8 3
1 3 -1 -3 5 3 6 7
```

#### 输出样例：

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7
```

#### 思路分析

暴力做法:
用4个结点，分别记录队头，队尾，队列中的最大值最小值。
先初始化当前窗口k的队列最大最小值。接着开始遍历数组
对于新进来的数，判断其是否大于或小于最大最小值，以最大值为例，若大于最大值，更新最大值并输出到数组中。
若小于最大值，则判断最大值是否在滑动过的窗口区间内，即查找当前最大值的位置i，若在，输出最大值。
若不在数组中，则需要查询当前区间内的最大最小值其所在的位置。
重复上述过程，直到找到最小数组。

上述做法的复杂点在于
1.查找当前最大值是否在区间内。
2.若最大值出队，需要再次查询当前区间内的最大最小值所在。

单调队列法引申：
解决方法：以最大值为例
1.利用坐标进行定位，存储最大值或者说区间内的值对应的定位。如`q[a[i]]`的形式。
经过他人方案考量，其实只要标记这个数再进入窗口时的i值，将这个i值存入即可。
2.在窗口滑动的过程中，如果i代表左侧，j代表右侧，如果j大于i，那么窗口中i就是无意义的，因为只要j在窗口中，最大值一定是j。那么队尾新进来的数j，会与现有队列中的值进行比较，找到其位置。
假如是5，队列是7，3，1。5的下标是j。队列中现有元素的下标是i(因为都在j左侧。)那么5入队后，3和1就失去了意义，重复该过程，队列就一定是单调减队列。而队头元素就是窗口新增元素的最大值。
但是因为窗口还会减去一个head，那么就要判定这个head下标对应的数组值是否就是head，如果是，队头出队，最大值顺延。

上述过程即单调队列的解决方案，并且有效解决了两个问题复杂点，并有效节省了空间开支，不需要再用`q[a[i]]`来做位置标记。
从时间复杂度开支的角度来说，就从暴力法的O(nk)降为了O(n)。

代码思路解析：
求最小值时。
1.当队列非空并且当前数小于队尾值时，队列出栈。当循环结束时，当前数入队。
2.当i移动出了窗口范围`i - k >= 1`并且队头值刚好就是数组窗口头值`a[i - k] == q.peekfirst()`时，队头出队。
3.当i移动到了窗口边界时，开始输出最小值，即输出队头，直到i到达边界，此时窗口同步移动到边界，循环结束。
### 代码

#### c++
```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <deque>
using namespace std;

const int N = 1000010;
int a[N];
int main()
{
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i ++ ) cin >> a[i];//读入数据
    deque<int> q;
    for(int i = 1; i <= n; i++)
    {
        while(q.size() && q.back() > a[i]) //新进入窗口的值小于队尾元素，则队尾出队列
            q.pop_back();
        q.push_back(a[i]);//将新进入的元素入队
        if(i - k >= 1 && q.front() == a[i - k])//若队头是否滑出了窗口，队头出队 
            q.pop_front();
        if(i >= k)//当窗口形成，输出队头对应的值
            cout << q.front() <<" ";
    }
    q.clear();
    cout << endl;

    //最大值亦然
    for(int i = 1; i <= n; i++)
    {
        while(q.size() && q.back() < a[i]) q.pop_back();
        q.push_back(a[i]);
        if(i - k >= 1 && a[i - k] == q.front()) q.pop_front(); 
        if(i >= k) cout << q.front() << " ";

    }
}
```


#### java代码与性能优化过程

初版，跑答案tle
```java
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Scanner;

public class SlidingWindow {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int N = 1000010;
        int[] a = new int[N];

        int n = scanner.nextInt();
        int k = scanner.nextInt();

        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextInt();
        }

        Deque<Integer> q = new ArrayDeque<>();

        // Minimum values
        for (int i = 1; i <= n; i++) {
            while (!q.isEmpty() && q.peekLast() > a[i]) {
                q.pollLast();
            }
            q.offerLast(a[i]);
            if (i - k >= 1 && q.peekFirst() == a[i - k]) {
                q.pollFirst();
            }
            if (i >= k) {
                System.out.print(q.peekFirst() + " ");
            }
        }

        q.clear();
        System.out.println();

        // Maximum values
        for (int i = 1; i <= n; i++) {
            while (!q.isEmpty() && q.peekLast() < a[i]) {
                q.pollLast();
            }
            q.offerLast(a[i]);
            if (i - k >= 1 && a[i - k] == q.peekFirst()) {
                q.pollFirst();
            }
            if (i >= k) {
                System.out.print(q.peekFirst() + " ");
            }
        }

        scanner.close();
    }
}
```

优化输入输出版本
运行时间800ms，可通过
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.StringTokenizer;

public class SlidingWindow {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder result = new StringBuilder();

        int N = 1000010;
        int[] a = new int[N];

        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());
        int n = Integer.parseInt(tokenizer.nextToken());
        int k = Integer.parseInt(tokenizer.nextToken());

        tokenizer = new StringTokenizer(reader.readLine());
        for (int i = 1; i <= n; i++) {
            a[i] = Integer.parseInt(tokenizer.nextToken());
        }

        Deque<Integer> q = new ArrayDeque<>();

        // Minimum values
        for (int i = 1; i <= n; i++) {
            while (!q.isEmpty() && q.peekLast() > a[i]) {
                q.pollLast();
            }
            q.offerLast(a[i]);
            if (i - k >= 1 && q.peekFirst() == a[i - k]) {
                q.pollFirst();
            }
            if (i >= k) {
                result.append(q.peekFirst()).append(" ");
            }
        }

        q.clear();
        result.append("\n");

        // Maximum values
        for (int i = 1; i <= n; i++) {
            while (!q.isEmpty() && q.peekLast() < a[i]) {
                q.pollLast();
            }
            q.offerLast(a[i]);
            if (i - k >= 1 && a[i - k] == q.peekFirst()) {
                q.pollFirst();
            }
            if (i >= k) {
                result.append(q.peekFirst()).append(" ");
            }
        }

        System.out.print(result.toString());

        reader.close();
    }
}
```

优化队列调用改为模拟队列版本
运行时间600ms。
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder result = new StringBuilder();

        int N = 1000010;
        int[] a = new int[N];
        int[] q = new int[N]; // 使用数组模拟队列

        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());
        int n = Integer.parseInt(tokenizer.nextToken());
        int k = Integer.parseInt(tokenizer.nextToken());

        tokenizer = new StringTokenizer(reader.readLine());
        for (int i = 1; i <= n; i++) {
            a[i] = Integer.parseInt(tokenizer.nextToken());
        }

        int frontMin = 1, rearMin = 0;
        int frontMax = 1, rearMax = 0;

        // Minimum values
        for (int i = 1; i <= n; i++) {
            while (rearMin >= frontMin && a[q[rearMin]] > a[i]) {
                rearMin--;
            }
            q[++rearMin] = i;
            if (i - k >= 1 && q[frontMin] == i - k) {
                frontMin++;
            }
            if (i >= k) {
                result.append(a[q[frontMin]]).append(" ");
            }
        }

        result.append("\n");

        // Maximum values
        for (int i = 1; i <= n; i++) {
            while (rearMax >= frontMax && a[q[rearMax]] < a[i]) {
                rearMax--;
            }
            // 队列非空判定。
            q[++rearMax] = i;
            if (i - k >= 1 && q[frontMax] == i - k) {
                frontMax++;
            }
            if (i >= k) {
                result.append(a[q[frontMax]]).append(" ");
            }
        }

        System.out.print(result.toString());

        reader.close();
    }
}
```

# KMP字符串匹配

## 题目

给定一个字符串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模式串 P 在字符串 S中多次作为子串出现。

求出模式串 P 在字符串 S 中所有出现的位置的起始下标。

#### 输入格式

第一行输入整数 N，表示字符串 P 的长度。

第二行输入字符串 P。

第三行输入整数 M，表示字符串 S的长度。

第四行输入字符串 S。

#### 输出格式

共一行，输出所有出现位置的起始下标（下标从 00 开始计数），整数之间用空格隔开。

#### 数据范围

$1≤N≤10^5$
$1≤M≤10^6$

#### 输入样例：

```
3
aba
5
ababa
```

#### 输出样例：

```
0 2
```


### 思路
推荐阅读：[深入浅出 next 数组 ](https://www.acwing.com/solution/content/129372/)
KMP算法的关键在于通过预处理模式串，构建一个辅助数组（部分匹配表），该数组记录了模式串中每个位置的最长相同前缀和后缀的长度。利用这个部分匹配表，算法能够在匹配失败时跳过一定长度，直接移动模式串，而不需要重新比较已经匹配的部分。

核心思想：在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。

相关基本概念：
1、s[ ]是主串，即比较长的字符串。
2、p[ ]是模板串，即比较短的字符串。
3、“部分匹配值”：前缀和后缀的最长共有元素的长度。
4、next[ ]是“部分匹配值表”，即next数组，`next[i]` 存储的就是使子串 `s[0…i]` 有最长相等前后缀的前缀的**最后一位的下标**。是算法的**核心概念**。
如s = “abababc”，`s[0...3]` = abab，k = 1，长度为 k + 1 的前缀与后缀分别是 `s[0…1]` 与 `s[2…3]`。此时`next[i] = 1`。此时存储的就是前缀的最后一位的下标`s[1] = b`。

next数组的求解过程：
1.初始化 next 数组，令 `j = next[0] = -1`。
2、让 i 在 1 ~ len - 1范围内遍历，对每个 i ，执行 3、4，以求解 `next[i]`。
3、直到 j 回退为 -1，或是 `s[i] == s[j + 1]` 成立，否则不断令 `j = next[j]`。
4、如果 `s[i] == s[j + 1]`，则 `next[i] = j + 1`；否则 `next[i] = j`。

不匹配时`j = next[j]`的原因：
因为next[]表示的是当前匹配的前缀最后字符下标，也可以理解为匹配长度，当下一个i字符不匹配时，我们只有缩短匹配串j。对于j的下一个匹配前后缀，在之前计算i时已经计算过了。即上一个存在最大公共j值的位置就是`next[j]`对应的值。也就是新的j缩短后应到的位置。如果一直匹配不到，那么就是j = -1，此时匹配串重新开始。


同理kmp的求解过程：
1、初始化 j = -1，表示 pattern 当前已被匹配的最后位。
2、让 i 遍历文本串 text，对每个 i，执行 3、4来试图匹配 `text[i]` 和`pattern[j + 1]`。
3、直到 j 回退到 -1 或者是 `text[i] == pattern[j + 1]`，否则不断令 `j = next[j]`。
4、如果 `text[i] == pattern[j + 1]`，则令 j ++。如果 j 达到 pattern_len - 1，说明 pattern 是 text 的子串。


结尾输出i - j的原因：
假设在文本串中的位置 `i` 处发生匹配成功，此时 `j` 的值为最长相等前缀的尾部位置。那么 `i - j` 就是文本串中匹配成功的起始位置，因为 `i - j` 表示当前匹配位置减去最长相等前缀的尾部位置，即模式串和文本串匹配的起始位置。


### 代码

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(reader.readLine());
        char[] p = reader.readLine().toCharArray();
        int m = Integer.parseInt(reader.readLine());
        char[] s = reader.readLine().toCharArray();

        int[] ne = new int[n];  //next数组
        ne[0] = -1;
        // 预处理模式串
        for (int i = 1, j = -1; i < n; i ++ ) {
            while (j != -1 && p[i] != p[j + 1]) {
                j = ne[j];
            }
            if (p[i] == p[j + 1]) {
                j ++;
            }
            ne[i] = j;
        }

        StringBuilder result = new StringBuilder();
        // KMP处理
        for (int i = 0, j = -1; i < m; i ++ ) {
            while (j != -1 && s[i] != p[j + 1]) {
                j = ne[j];
            }
            if (s[i] == p[j + 1]) {
                j ++ ;
            }
            if (j == n - 1) {   // j 从-1开始
                result.append(i - j).append(' ');
                j = ne[j];
            }
        }
        System.out.println(result.toString().trim());
    }
}
```


# Trie


![[Pasted image 20240222091627.png]]

## 字符串匹配统计

维护一个字符串集合，支持两种操作：

1. `I x` 向集合中插入一个字符串 x�；
2. `Q x` 询问一个字符串在集合中出现了多少次。

共有 N� 个操作，所有输入的字符串总长度不超过 105105，字符串仅包含小写英文字母。

#### 输入格式

第一行包含整数 N�，表示操作数。

接下来 N� 行，每行包含一个操作指令，指令为 `I x` 或 `Q x` 中的一种。

#### 输出格式

对于每个询问指令 `Q x`，都要输出一个整数作为结果，表示 x� 在集合中出现的次数。

每个结果占一行。

#### 数据范围

1≤N≤2∗1041≤�≤2∗104

#### 输入样例：

```
5
I abc
Q abc
Q ab
I ab
Q ab
```

#### 输出样例：

```
1
0
1
```


### 思路

通过树形结构存储每个字符串，根节点为空，遍历字符串，存在对应字母子节点则往下遍历，不存在则创建该子节点，直到遍历完字符串，对于串的最后一个结点打上关键字标记表示以该结点结尾的是一个串/单词。

在实际存储时，用数组模拟这棵树。
用一个二维数组存储每个结点的子节点，为0表示不存在，。
用一个一维数组存储结点的关键字。
同样，为了确保结点唯一性，需要idx自增。

此外，需要注意str的输入输出格式，char数组的读入，应该先通过string读入串，再转化为数组，不可直接使用`scanner.next(str)`。

### 代码

```java
import java.util.*;  
  
public class Main {  
  
    static int N = 100010;  
    // son[][]存储子节点的位置，分支最多26条；  
    // cnt[]存储以某节点结尾的字符串个数（同时也起标记作用）  
    // idx表示当前要插入的节点是第几个,每创建一个节点值+1  
    static int[][] son = new int[N][26];  
    static int[] cnt = new int[N];  
    static int idx;  
    static char[] str = new char[N];  
  
    public static void main(String[] args) {  
        Scanner scanner = new Scanner(System.in);  
        int n = scanner.nextInt();  
  
        while (n -- > 0) {  
            String op = scanner.next();  
            String inputStr = scanner.next();  
            str = inputStr.toCharArray();  
            if ("I".equals(op)) {  
                insert(str);  
            } else {  
                System.out.println(query(str));  
            }  
  
        }  
    }  
  
    private static void insert(char[] str) {  
        int p = 0;  //表示当前遍历到的结点  
        // 构造和遍历trie树  
        for (int i = 0; i < str.length; i ++ ) {  
            int q = str[i] - 'a';  
            // 当前结点的子节点是否存在，不存在就创建。  
            if (son[p][q] == 0) son[p][q] = ++ idx;  
            p = son[p][q];  
        }  
        cnt[p] ++ ;//结束标记，也表示  
    }  
  
    private static int query(char[] str) {  
        int p = 0;  
        for (int i = 0; i < str.length; i ++ ) {  
            int q = str[i] - 'a';  
            if (son[p][q] == 0) return 0;  
            p = son[p][q];  
        }  
        return cnt[p];  
    }  
}
```

## 最大异或对

在给定的 N 个整数 A1，A2……A 中选出两个进行 xor（异或）运算，得到的结果最大是多少？

#### 输入格式

第一行输入一个整数 N。

第二行输入 N 个整数 A1～AN。

#### 输出格式

输出一个整数表示答案。

#### 数据范围

$1≤N≤10^5$
$0≤Ai<2^{31}$

#### 输入样例：

```
3
1 2 3
```

#### 输出样例：

```
3
```

### 思路

构建一个二进制字典树，因为题意的数最大值为$2^{31}$，而一个整数,是可以转化成为一个32位的二进制数,而也就可以变成长度为32位的二进制字符串，从而可以存储入字典树中。
通过这种方式，将所有题目的数insert到字典树中。

接着开始遍历每个数对应的最大query值，
因为题目所求的是最大值，因此需要从最高位开始进行查找，假设原数是0100，那么就先查找1，存在，走到1，接着查找0，存在，走到10，查找1，不存在。查看是否有子节点路径，没有，查找结束，输出结果10，对应值为1100，即11。

通过这样的方式，就将暴力解法的O($n^2$)优化到了近似于O(n)的地步，因为第二重循环只需一趟即可查出最大值，1趟跑32步。
![[ee99b9b122631d812cb83b1e2559a99.jpg]]
即对于`trie[][]`数组来说，其结构为`trie[N * 32][2]`

### 代码

```java
import java.io.*;

public class Main {

    static int N = 100010, idx = 0;
    static int[][] trie = new int [N*32][2];

    //  插入
    public static void insert(int x) {
        int p = 0;
        // 31位，从最高位30开始插入和查询
        for (int i = 30; i >= 0; i -- ) {
            int q = x >> i & 1; //求x的第i位的二进制形式
            if (trie[p][q] == 0) trie[p][q] = ++ idx;
            p = trie[p][q];
        }
    }
    //  查询
    public static int query(int x) {
        int p = 0, res = 0;
        for (int i = 30; i >= 0; i -- ) {
            int q = x >> i & 1;
            //  用1 - u 即可代表0/1 的对立情况
            if (trie[p][1 - q] == 0) {
                p = trie[p][q];
            } else {
                p = trie[p][1 - q];
                res += 1 << i;
            }
        }
        return res;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));

        int n = Integer.parseInt(reader.readLine());
        String[] s = reader.readLine().split(" ");
        for (int i = 0; i < n; i ++ ) {
            insert(Integer.parseInt(s[i]));
        }
        int res = 0;
        for (int i = 0; i < n; i ++ ) {
            res = Math.max(res, query(Integer.parseInt(s[i])));
        }
        writer.write(res + " ");
        writer.close();
    }
}
```


# 并查集

## 合并集合

[相关思路](https://www.acwing.com/solution/content/116728/)

一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。

现在要进行 m 个操作，操作共有两种：

1. `M a b`，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
2. `Q a b`，询问编号为 a 和 b 的两个数是否在同一个集合中；

#### 输入格式

第一行输入整数 n 和 m。

接下来 m 行，每行包含一个操作指令，指令为 `M a b` 或 `Q a b` 中的一种。

#### 输出格式

对于每个询问指令 `Q a b`，都要输出一个结果，如果 a 和 b 在同一集合内，则输出 `Yes`，否则输出 `No`。

每个结果占一行。

#### 数据范围

$1≤n,m≤10^5$
#### 输入样例：

```
4 5
M 1 2
M 3 4
Q 1 2
Q 1 3
Q 3 4
```

#### 输出样例：

```
Yes
No
Yes
```


### 思路

并查集的核心思路即用一个元素代表整个集合整体。
在常规的思路中，是用树代表一个集合，每个树的根节点的值代表该集合。在合并过程中即用本集合的根节点插入成为另一个集合根结点的子树。
1、**初始化：** 将每个元素单独看作一个集合，即每个元素自成一棵树。
2、 **合并（Union）：** 将两个集合合并为一个集合。这通过将其中一个集合的根节点连接到另一个集合的根节点来完成。这样，两个集合就合并成了一个集合。
3、**查找（Find）：** 查找某个元素所属的集合（树）。通过递归确定我的树根是否是我，不是则查找新的结点的树根，直到找到该元素所在树的根节点，从而确定其所属的集合。
并查集的优势在于在合并操作和查找操作上的时间复杂度都很低，近乎是常数时间。这使得并查集在处理一些涉及集合合并和查找问题的算法中非常高效，比如用于图的最小生成树算法中的Kruskal算法。

#### 数组模拟法-仅限本题
建立初始数组，数组中的下标与值一一对应，代表初始的森林。

1、a、b合并操作
查找代表b的元素与代表a的元素，将a的祖先/树根修改为b的祖先/树根。

2、询问操作x
查找x的祖先是不是自身，如果是，返回x的祖先。
如果不是，将x的祖先改为x的祖先的祖先，递归该过程，最后返回x的祖先。
### 代码

```java
import java.util.*;

public class Main {

    static int N = 100010;
    static int []p = new int[N];    //存放森林数组
    // 查找q所属的合集对应代表元素。
    private static int find(int x) {
        //  如果我不是我的祖先，就将我的祖先替换成我的祖先的祖先，最后返回我的祖先
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        //  初始时所有父节点指向自身。
        for (int i = 1; i <= n; i ++ ) {
            p[i] = i ;
        }
        while (m -- > 0) {
            String op = scanner.next();
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            if ("Q".equals(op)) {
                if (find(a) == find(b)) {
                    System.out.println("Yes");
                } else {
                    System.out.println("No");
                }
            } else {
                //  将a结点的祖先指向b结点的祖先。
                p[find(a)] = find(b);
            }
        }
    }
}
```


## 连通块中点的数量

给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。

现在要进行 m 个操作，操作共有三种：

1. `C a b`，在点 a 和点 b 之间连一条边，a 和 b 可能相等；
2. `Q1 a b`，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；
3. `Q2 a`，询问点 a 所在连通块中点的数量；

#### 输入格式

第一行输入整数 n 和 m。

接下来 m 行，每行包含一个操作指令，指令为 `C a b`，`Q1 a b` 或 `Q2 a` 中的一种。

#### 输出格式

对于每个询问指令 `Q1 a b`，如果 a 和 b 在同一个连通块中，则输出 `Yes`，否则输出 `No`。

对于每个询问指令 `Q2 a`，输出一个整数表示点 a 所在连通块中点的数量

每个结果占一行。

#### 数据范围

$1≤n,m≤10^5$

#### 输入样例：

```
5 5
C 1 2
Q1 1 2
Q2 1
C 2 5
Q2 5
```

#### 输出样例：

```
Yes
2
3
```


### 思路

利用例题的思路。
对于问题一，a和b之间连一条边，就让a的祖先指向b。
对于问题二，查找a和b是否为同一祖先即可。
对于问题三，建立一个新的数组，每次a的祖先指向b的祖先，就让下标为b的祖先的数组值加上a的祖先原有值即可。初始化下所有下标值为1。


#### 错误代码警示
```java
//  该写法导致a和b在同一棵树中时cnt继续增加，使得结果暴增最终数据溢出。
if ("C".equals(op)) {  
    int a = scanner.nextInt();  
    int b = scanner.nextInt();  
    //  如果两个数在同一个  
    if (a != b) {  
        cnt[find(b)] += cnt[find(a)];  
        p[find(a)] = find(b);  
    }  
}
//  正确写法是将if中的a和b判定修改为对根节点的判定。
if ("C".equals(op)) {  
    int a = scanner.nextInt();  
    int b = scanner.nextInt();  
    //  如果两个数在同一个  
    if (find(a) != find(b)) {  
        cnt[find(b)] += cnt[find(a)];  
        p[find(a)] = find(b);  
    }   
}
```
### 代码

```java
import java.util.*;

public class Main {
    static int N = 100010;
    static int []p = new int[N];
    static int []cnt = new int[N];

    private static int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        //  树的初始化
        for (int i = 1; i <= n; i ++ ) {
            p[i] = i;
            cnt[i] = 1;
        }
        while (m -- > 0) {
            String op = scanner.next();
            if ("C".equals(op)) {
                int a = scanner.nextInt();
                int b = scanner.nextInt();
                //  如果两个数不在同一连通块，才能增加，注意先计数再统一根节点。
                if (find(a) != find(b)) {
                    cnt[find(b)] += cnt[find(a)];
                    p[find(a)] = find(b);
                } else continue;
            } else if ("Q1".equals(op)) {
                int a = scanner.nextInt();
                int b = scanner.nextInt();
                if (find(a) == find(b))
                    System.out.println("Yes");
                else
                    System.out.println("No");
            } else {
                int a = scanner.nextInt();
                System.out.println(cnt[find(a)]);
            }
        }
    }
}
```


## 食物链(较难)


动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。

A 吃 B，B 吃 C，C 吃 A。

现有 N 个动物，以 1∼N编号。

每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 N 个动物所构成的食物链关系进行描述：

第一种说法是 `1 X Y`，表示 X 和 Y 是同类。

第二种说法是 `2 X Y`，表示 X 吃 Y。

此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。

当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

1. 当前的话与前面的某些真的话冲突，就是假话；
2. 当前的话中 X 或 Y 比 N 大，就是假话；
3. 当前的话表示 X 吃 X，就是假话。

你的任务是根据给定的 N 和 K 句话，输出假话的总数。

#### 输入格式

第一行是两个整数 N 和 K，以一个空格分隔。

以下 K 行每行是三个正整数 D，X，Y两数之间用一个空格隔开，其中 D 表示说法的种类。

若 D=1，则表示 X 和 Y 是同类。

若 D=2，则表示 X 吃 Y。

#### 输出格式

只有一个整数，表示假话的数目。

#### 数据范围

1≤N≤50000,  
0≤K≤1000000
#### 输入样例：

```
100 7
1 101 1 
2 1 2
2 2 3 
2 3 3 
1 1 3 
2 3 1 
1 5 5
```

#### 输出样例：

```
3
```

### 思路

声称x和y是同类或者天敌的时候，进行判断，如果x和y不在同一个并查集，那就合并这两个并查集并认为他说的是真的；如果在同一个并查集，那就判断是否是他声称的关系。加进来的并不一定是单点，有可能是之前就有内部关系的一个大集合（只是两个集合之前没有联系罢了）

#### 带扩展域的并查集

首先， 在带扩展域的并查集 中 x 不再只是一个 值，而是一个事件； 
规定    x       为 "事件 x 为 A 类动物"；
规定  x + N     为 "事件 x 为 B 类动物"；
规定 x + N * 2  为 "事件 x 为 C 类动物"；
因为A吃B，B吃C，C吃A
`p[find(X)] = find(Y)` 表示 
    事件 X 为 A 类动物 和 事件 Y 为 A 类动物 同时发生

X 与 Y 为同种动物 等价于 
	`p[ find(X) ] = find(Y);
    `p[ find(X + N)] = find(Y + N);`
    `p[ find(X + N * 2)] = find(Y + N * 2);``



`p[find(X)] = find(Y + N) `表示
    事件 X 为 A 类动物 和 事件 Y 为 B 类动物 同时发生

X 吃 Y 等价于
	`p[ find(X) ] = find(Y + N);`
    `p[ find(X + N)] = find(Y + N * 2);`
    `p[ find(X + N * 2)] = find(Y);`

因此，判断一句话是否为真只需要判断x和y现有的关系即可。
如d = 1，判断x和y是否是同类，则判断现有x是否能吃y和y是否能吃x即可。
如d = 2，判断x能否吃y，则判断现有y是否能吃x或两者是否是同类即可。

#### 边权解法的并查集
[参考思路](https://www.acwing.com/solution/content/16144/)

并查集之边带权
思路：只要有关系，就属于同一个集合，就加入到集合中去（不管是同类or异类）
所以边带权的并查集问题本质上只在维护一个大的集合（其他的都是单个点逐一加到大集合里）

精髓：只要两个元素在同一个集合里，就能通过他们与根节点的距离知道他们之间的关系。

用“距离”来描述关系、判断关系，所有的距离都以根节点为基准，按照mod类别数(3)分为3类。
“距离”：x吃y表示y到x的距离为1. y是第0代，吃y的x是第1代，吃x的是第2代…根节点是第0代
三种关系：用点到根节点之间的距离表示其余根节点之间的关系
mod 3 = 1:可以吃根节点
mod 3 = 2:可以被根节点吃
mod 3 = 0:和根节点同类
把集合中所有的点划分为上述三类。
因此整棵树在处理后最多分为0、1、2、3共计4代

两个数组的定义：
p[]:父节点,
d[]:其值表示关系，到父节点（不是根节点）的距离(初始是0，随着路径压缩会逐渐增大)
我们只能获得点到其直接父节点的距离。路径压缩和更新边权的时候也是这样。通过路径压缩，不断累加每个点到父节点的距离，最终就表示x到根节点的距离，即x和根节点的关系，并进行存储。因为在路径压缩后d[]会丢失。


![[食物链.jpg]]


表示同类时：`d[x]+d[px]-d[y])%3 == 0`，故有`d[px] = d[y] - d[x];`
首先，我们考虑并查集中的路径压缩。在路径压缩过程中，将节点 `x` 的父节点路径上的所有节点直接连接到树根上，这会改变这些节点的父节点，并且需要更新这些节点的边权。

假设节点 `x` 的父节点为 `px`，并且在路径压缩之前 `x` 到根节点的距离为 `d[x]`，`px` 到根节点的距离为 `d[px]`。在路径压缩之后，将 `x` 的父节点路径上的所有节点都连接到树根上，因此 `x` 到根节点的新距离为 `d[x] + d[px]`。

现在，回到条件 `(d[x] + d[px] - d[y]) % 3 == 0`。这个条件的目的是确保节点 `x` 和节点 `y` 在同一集合，并且它们属于同一类。因为我们在路径压缩过程中更新了边权，所以我们需要考虑 `x` 的新距离 `d[x] + d[px]`。

加上 `x` 的父节点 `px` 到根节点的距离 `d[px]` 是为了确保在考虑路径压缩后的新距离时，边权能够正确地反映节点之间的关系。这样，通过 `(d[x] + d[px] - d[y]) % 3 == 0` 条件的判断，可以确保合并操作只会在同一类的节点之间进行，维护了集合关系的正确性。

表示a吃b时：
将a和b合并后，a到根节点的距离比b到根节点的距离多1。
而合并后a到b的根节点的距离表示为：`d[a] + d[pa]` ，b到根结点的距离不变，为`d[b]`所以有：`d[a] + d[pa] - d[b] = 1`
### 代码

#### 带扩展域解法
```java
import java.util.*;

public class Main {
    static final int N = 50010;
    static final int M = N * 3;

    static int []p = new int[M];
    private static int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    public static void main(String [] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        for (int i = 1; i < M; i ++ ) p[i] = i;
        int res = 0;

        while (m -- > 0) {
            int d = scanner.nextInt();
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            if (a > n || b > n) {
                res ++ ;
                continue;
            }
            if (a == b) {
                if (d == 2) res ++ ;
                continue;
            }
            if (d == 1) {
                //  如果b能吃a或者a能吃b，则两者不是同类，那么就是假话
                if (find(a) == find(b + N) || find(a + N) == find(b)) {
                    res ++ ;
                    continue;
                }

                p[find(a)] = find(b);
                p[find(a + N)] = find(b + N);
                p[find(a + N * 2)] = find(b + N * 2);
            } else {
                //  如果b吃a或者a与b是同类，那么这句话就是假话。
                if (find(b) == find(a + N) || find(a) == find(b)) {
                    res ++ ;
                    continue;
                }

                p[find(a)] = find(b + N);
                p[find(a + N)] = find(b + N * 2);
                p[find(a + N * 2)] = find(b);
            }
        }
        System.out.println(res);
    }
}
```

#### 边权解法

```java
import java.util.*;

public class Main {
    static final int N = 50010;

    static int[] p = new int[N];
    static int[] d = new int[N];

    private static int find(int x) {
        if (p[x] != x) {
            int t = find(p[x]); //压缩父结点以上结点。
            d[x] += d[p[x]];
            p[x] = t;
        }
        return p[x];
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();

        for (int i = 1; i <= n; i ++ ) {
            p[i] = i;
        }

        int res = 0;
        while (m -- > 0) {
            int t = scanner.nextInt();
            int a = scanner.nextInt();
            int b = scanner.nextInt();

            if (a > n || b > n) {
                res ++ ;
                continue;
            } else {
                int pa = find(a);
                int pb = find(b);
                if (t == 1) {
                    if (pa == pb && (d[a] - d[b]) % 3 != 0) res ++ ;
                    //  如果不再同一棵树中。需要合并
                    else if (pa != pb){
                        p[pa] = pb;
                        d[pa] = d[b] - d[a];
                    }
                } else {
                    //r=2表示x吃y
                    // =》x到根节点的距离比y到根节点的距离多1 =》(d[x]-d[y]-1)%3==0
                    if (pa == pb && (d[a] - d[b] - 1) % 3 != 0) res ++ ;
                    else if (pa != pb) {
                        p[pa] = pb;
                         //因为x吃y，所以d[x]+?-d[y]-1==0 => ?=d[y]+1-d[x],其中？为d[px]
                        d[pa] = d[b] + 1 - d[a];
                    }
                }
            }
        }

        System.out.println(res);
    }
}
```
