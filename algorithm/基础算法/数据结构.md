
# 模拟栈与链表

## 单链表
[题目链接](https://www.acwing.com/problem/content/828/)
  
实现一个单链表，链表初始为空，支持三种操作：

1. 向链表头插入一个数；
2. 删除第 k个插入的数后面的数；
3. 在第 k 个插入的数后插入一个数。

现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。

**注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，第 n个插入的数。

#### 输入格式

第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

1. `H x`，表示向链表头插入一个数 x。
2. `D k`，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。
3. `I k x`，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。

#### 输出格式

共一行，将整个链表从头到尾输出。

#### 数据范围

1≤M≤100000
所有操作保证合法。

#### 输入样例：

```
10
H 9
I 1 1
D 1
D 0
H 6
I 3 6
I 4 5
I 4 5
I 3 4
D 6
```

#### 输出样例：

```
6 4 6 5
```

#### 思路
一般用两个数组分别来存储结点的值和指针，此处使用`e[N] `和`ne[N]`，那么0号点假设值是3，那么即`e[0] = 3, ne[0] = 1`。如下图所示。
其中空结点下标用-1表示。具体操作：
1.将链表初始化，让头结点为-1，用一个idx表示空余指针结点，或者说轮到哪个空余指针了。
2.head = 表示头结点指向的第一个结点的地址。
所以在头结点插入即表示为
```java
ne[idx] = head;  // 将头结点指向的指针赋给新的结点
e[idx] = k;      // 赋值
head = idx ++ ;  // 头结点指向该新的结点，idx 指向新的空余结点。
```
![[Pasted image 20221205170909.png]]
3.对于题意来说，k被认为是第几个插入的数，而数组从0开始，因此涉及k的操作指向的数组是k - 1的。
4.因此对于k = 0表示头结点删除也需要特判，即`head = next[head]`

### 代码

#### c++
```c++
#include <iostream>

using namespace std;

const int N = 100010;

//head 表示头结点的下标，e[N]表示结点的值，ne[N]表示结点的next指针是多少
//idx用于存储当前已经用到了哪个地址，相当于一个指针。
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;//-1表示空
    idx = 0; //每个点都可以被分配，所以从0开始
}

//将x插入头结点
void add_to_head(int x)
{
    e[idx] = x; //插值
    ne[idx] = head;//插入的结点的下一个指向head指向的结点
    head = idx ++;//head指向当前插入的结点
    //idx用过了，加加
}

//将x插入到第k个输入的点的后面
void add(int k, int x)
{
    e[idx] = x;//如果idx跟k不太符合怎么办？
    ne[idx] = ne[k];//这个插入是顺序插入，而不是任意插入，k和idx一定符合，并且删除并不会影响，此外哪怕是随意插入idx的顺序增加与k也不会导致冲突
    ne[k] = idx ++;//k和idx的值，所以并不影响。
}

//将下标第k个后的点删掉，因为idx从0开始，所以第k实际指的坐标是k - 1
//那么如果k = 0那么就是删去的头结点。
void remove(int k)
{
    ne[k] = ne[ne[k]];   
}

int main()
{
    int m;
    cin >> m;
    
    init();
    while (m -- )
    {
        int k, x;//x是值，k表示第几个。
        char op; //操作符
        
        cin >> op;
        if (op == 'H')
        {
            cin >> x;
            add_to_head(x);
        }
        else if (op == 'D')
        {
            cin >> k;
            //要判定删的是不是头结点。
            if (!k) head = ne[head];//head变成了它指向的点。
            remove(k - 1);
        }
        else
        {
            cin >> k >> x;
            add(k - 1, x);
        }
    }
    //i如果指向的head不是空，那么就输出链表。
    //i = head 表示i变成head指向的点，即头结点的下一个点，此时输出e[i]，
    //然后再让i指向ne[i]即指向下一个点
    for (int i = head; i != -1; i = ne[i]) cout << e[i] << ' ';
    cout << endl;
    
    return 0;
}
```
#### java

```java
import java.util.*;

public class Main {
    static final int N = 100010;
    // idx 表示新的空链表结点，同时也代表第k个插入的数。
    static int n, idx, head;
    static int[] e = new int[N], next = new int[N];

    public static void init() {
        idx = 0;
        head = -1;
    }
    // 在头结点插入一个数，head值表示头结点的地址。
    public static void add_head(int x) {
        e[idx] = x;
        next[idx] = head;
        head = idx ++ ;
    }

    public static void del_node(int k) {
        next[k] = next[next[k]];
    }

    public static void insert_node(int k, int x) {
        next[idx] = next[k];
        e[idx] = x;
        next[k] = idx ++ ;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt();
        init();
        while (n -- > 0) {
            char op = scanner.next().charAt(0);
            //链表头插入
            if (op == 'H') {
                int x = scanner.nextInt();
                add_head(x);
            }
            if (op == 'D') {

                int k = scanner.nextInt();
                if (k == 0) head = next[head];
                else del_node(k - 1);
            }
            if (op == 'I') {
                int k = scanner.nextInt();
                int x = scanner.nextInt();
                insert_node(k - 1, x);
            }
        }
        // 定义一个指针来跑到最后一个地址。
        int res = head;
        while (res != -1) {
            System.out.println(e[res]);
            res = next[res];
        }
    }
}
```

## 双链表
[题目链接](https://www.acwing.com/problem/content/829/)

实现一个双链表，双链表初始为空，支持 5 种操作：

1.  在最左侧插入一个数；
2.  在最右侧插入一个数；
3.  将第 k 个插入的数删除；
4.  在第 k 个插入的数左侧插入一个数；
5.  在第 k 个插入的数右侧插入一个数

现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。

**注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。

#### 输入格式

第一行包含整数 M，表示操作次数。

接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

1.  `L x`，表示在链表的最左端插入数 x。
2.  `R x`，表示在链表的最右端插入数 x。
3.  `D k`，表示将第 k 个插入的数删除。
4.  `IL k x`，表示在第 k 个插入的数左侧插入一个数。
5.  `IR k x`，表示在第 k 个插入的数右侧插入一个数。

#### 输出格式

共一行，将整个链表从左到右输出。

#### 数据范围

1≤M≤100000
所有操作保证合法。

#### 输入样例：

```
10
R 7
D 1
L 3
IL 2 10
D 3
IL 2 7
L 8
R 9
IL 4 7
IR 2 2
```

#### 输出样例：

```
8 7 7 3 2 9
```

#### 思路

双链表相比单链表，需要多一个指向上一结点的数组，但是因为头尾相连，因此不再需要head表示头指针(除非题目特意要求)。
操作原理上与单链表相似
1.idx表示当前空余指针结点
2.`next[]、last[]`表示下一个和上一个，用`next[0]`表示头，`last[1]`表示尾
3.在单链表中，操作 `k - 1` 是因为链表中只存储了当前节点的下一个节点的信息，要找到第 `k` 个位置的节点，需要从头节点开始按序遍历 `k - 1` 次，因为链表中的位置从1开始计数，而链表的索引从0开始。

而在双链表中，除了存储了当前节点的下一个节点的信息外，还同时存储了当前节点的上一个节点的信息。这种设计使得在双链表中可以更容易地在指定位置进行插入和删除操作，因为通过 `l[]` 和 `r[]` 数组可以直接定位到前后节点。在这个实现中，使用 `l[k + 1]` 或者 `r[k]` 来表示第 `k` 个节点后面的节点。

### 代码

#### java
```java
import java.util.*;  
  
public class Main {  
    static final int N = 100010;  
    // idx 表示新的空链表结点，同时也代表第k个插入的数。  
    static int n, idx;  
    static int[] e = new int[N];  
    static int[] next = new int[N], last = new int[N];  
  
    // 初始化两个头尾结点，这两个结点不存放数据，因此对应的idx为2，即2是新的空闲结点。  
    public static void init() {  
        next[0] = 1;  
        last[1] = 0;  
        idx = 2;  
    }  
    private static void insert_head(int x) {  
    }  
  
    private static void insert_tail(int x) {  
    }  
  
    private static void insert_right() {  
    }  
  
    private static void insert_left() {  
    }  
  
    private static void del(int k) {  
    }  
  
  
    public static void main(String[] args) {  
        Scanner scanner = new Scanner(System.in);  
        n = scanner.nextInt();  
  
        init();  
        while (n -- > 0) {  
            String str = scanner.next();  
            if ("R".equals(str)) {  
                int x = scanner.nextInt();  
                insert_head(x);  
            } else if ("L".equals(str)) {  
                int x = scanner.nextInt();  
                insert_tail(x);  
            } else if ("D".equals(str)) {  
                int k = scanner.nextInt();  
                del(k);  
            } else if ("IL".equals(str)) {  
                int k = scanner.nextInt();  
                int x = scanner.nextInt();  
                insert_left();  
            } else if ("IR".equals(str)) {  
                int k = scanner.nextInt();  
                int x = scanner.nextInt();  
                insert_right();  
            }  
        }  
    }  
  
}
```